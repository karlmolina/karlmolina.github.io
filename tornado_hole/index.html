<!doctype html>
<html lang="en">
<head>
    <script src="https://pixijs.download/release/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/math-extras@7.0.5/dist/math-extras.min.js"></script>
    <link href="../styles.css" rel="stylesheet"/>
    <title></title>
</head>
<body>
<script>
  let nodes, state, mouseNode;
  // const { createVector, color, stroke,
  // strokeWeight, point, createCanvas, background, mouseX, mouseY, mouseIsPressed} = s;

  function createVector(x, y) {
    return new PIXI.Point(x, y);
  }

  class Node {
    constructor(obj, index, lock = false) {
      this.obj = obj;
      this.lock = lock;
      this.index = index;
      this.v = createVector(0, 0);
      this.a = createVector(0, 0);
      this._children = [];
      this.weight = 1;
      this.pause = false;
    }

    averageChildren() {
      const average = createVector(0, 0);
      for (const child of this.children()) {
        average.add(child.obj.position, average);
      }
      average.multiplyScalar(1 / this.children().length, average);
      return average;
    }

    updateAverage() {
      if (this.lock || this.pause) {
        return;
      }
      for (const child of this.children()) {
        this.v.add(child.obj.position.subtract(this.obj.position).multiplyScalar(0.1 * child.weight), this.v);
      }
    }

    updatePhysics() {
      if (this.pause) {
        return;
      }
      this.a.multiplyScalar(0.06, this.a);
      this.v.add(this.a, this.v);
      this.v.multiplyScalar(.99, this.v);
      this.obj.position.add(this.v, this.obj.position);
    }

    addChild(nodeIndex) {
      const node = nodes[nodeIndex];
      if (node === undefined) {
        return;
      }
      if (!this.lock) {
        this._children.push(nodeIndex);
      }
      if (!node.lock) {
        node._children.push(this.index);
      }
    }

    children() {
      return this._children.map((i) => nodes[i]);
    }
  }

  const width = window.innerWidth;
  const height = window.innerHeight;

  function setup() {
    const spacing = 20;
    const nWide = Math.floor(width / spacing);
    const nHigh = Math.floor(height / spacing);
    nodes = {};
    state = 0;

    let circle = new PIXI.Graphics();
    circle.beginFill(0x000000);
    circle.drawCircle(0, 0, 3);
    for (let i = 0; i < nHigh; i += 1) {
      for (let j = 0; j < nWide; j += 1) {
        const obj = app.stage.addChild(new PIXI.Graphics(circle.geometry));
        obj.position.set(j * spacing + 10, i * spacing + 10);
        let node = new Node(obj);
        if (i === 0 || j === 0 || j === nWide - 1 || i === nHigh - 1) {
          node.lock = true;
        }
        node.index = i * nWide + j;
        nodes[node.index] = node;
        // above
        node.addChild((i - 1) * nWide + j);
        // above left
        // node.addChild(nodes[(i - 1) * n + j - 1]);
        // above right
        // node.addChild(nodes[(i - 1) * n + j + 1]);
        // left
        node.addChild(i * nWide + j - 1);
      }
    }
  }

  // Create the application helper and add its render target to the page
  let app = new PIXI.Application({ antialias: true, background: '0xffffff', width: width, height: height });
  document.body.appendChild(app.view);
  setup();
  const mouse = new PIXI.Point();
  let mouseIsPressed = false;
  app.stage.interactive = true;
  app.stage.hitArea = app.screen;
  app.stage.addEventListener('pointermove', (e) => {
    mouse.copyFrom(e.global);
    if (mouseIsPressed) {
      mouseNode.obj.position.copyFrom(mouse);
      mouseNode.pause = true;
      for (const child of mouseNode.children()) {
        child.obj.position.copyFrom(mouse);
        child.pause = true;
      }
    }
  });
  app.stage.addEventListener('pointerdown', (event) => {
    mouseIsPressed = true;
    for (const node of Object.values(nodes)) {
      if (node.lock) {
        continue;
      }
      node.weight = 1;
      if (event.global.subtract(node.obj.position).magnitude() < 20) {
        mouseNode = node;
        mouseNode.weight = 1;
        break;
      }
    }
    mouseNode.obj.position.copyFrom(mouse);
    mouseNode.pause = true;
    for (const child of mouseNode.children()) {
      child.obj.position.copyFrom(mouse);
      child.pause = true;
    }

  });
  app.stage.addEventListener('pointerup', (event) => {
    mouseIsPressed = false;
    mouseNode.weight = 1;
    mouseNode.obj.position.copyFrom(mouseNode.averageChildren());
  });
  app.stage.addEventListener('touchstart', (event) => {
  });
  app.ticker.add((delta) => {
    for (const node of Object.values(nodes)) {
      if (!mouseIsPressed) {
        node.pause = false;
      }
      node.updateAverage();
    }
    for (const node of Object.values(nodes)) {
      node.updatePhysics();
    }
  });
</script>
</body>
</html>