<!doctype html>
<html lang="en">
<head>
    <script src="https://pixijs.download/release/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@pixi/math-extras@7.0.5/dist/math-extras.min.js"></script>
    <link href="../styles.css" rel="stylesheet"/>
    <title></title>
</head>
<body>
<script>
  let nodes, state, mouseNode;
  // const { createVector, color, stroke,
  // strokeWeight, point, createCanvas, background, mouseX, mouseY, mouseIsPressed} = s;

  function createVector(x, y) {
    return new PIXI.Point(x, y);
  }

  class Node {
    constructor(obj, index, lock = false) {
      this.obj = obj;
      this.lock = lock;
      this.index = index;
      this.v = createVector(0, 0);
      this.a = createVector(0, 0);
      this._children = [];
    }

    updateAverage() {
      if (this.lock) {
        return;
      }
      const average = createVector(0, 0);
      for (const child of this.children()) {
        average.add(child.obj.position, average);
        this.v.add(child.obj.position.subtract(this.obj.position).multiplyScalar(0.1), this.v);
      }
      // if (this._children.length !== 0) {
      //   average.multiplyScalar(1 / this._children.length, average);
      // }
      // this.v.add(average.subtract(this.obj.position).multiplyScalar(1), this.v);
    }

    updatePhysics() {
      this.a.multiplyScalar(0.06, this.a)
      this.v.add(this.a, this.v)
      this.v.multiplyScalar(.99, this.v)
      this.obj.position.add(this.v, this.obj.position);
    }

    addChild(nodeIndex) {
      const node = nodes[nodeIndex];
      if (node === undefined) {
        return;
      }
      if (!this.lock) {
        this._children.push(nodeIndex);
      }
      if (!node.lock) {
        node._children.push(this.index);
      }
    }

    children() {
      return this._children.map((i) => nodes[i]);
    }
  }

  const width = window.innerWidth;
  const height = window.innerHeight;

  function setup() {

    const nWide = 100;
    const nHigh = 80;
    const xSpacing = width / nWide;
    const ySpacing = height / nHigh;
    nodes = {};
    state = 0;

    let circle = new PIXI.Graphics();
    circle.beginFill(0x000000);
    circle.drawCircle(0, 0, 3);
    for (let i = 0; i < nHigh; i += 1) {
      for (let j = 0; j < nWide; j += 1) {
        const obj = app.stage.addChild(new PIXI.Graphics(circle.geometry));
        obj.position.set(j * xSpacing + 10, i * ySpacing + 10);
        let node = new Node(obj);
        if (i === 0 || j === 0 || j === nWide - 1 || i === nHigh - 1) {
          node.lock = true;
        }
        node.index = i * nWide + j;
        nodes[node.index] = node;
        // above
        node.addChild((i - 1) * nWide + j);
        // above left
        // node.addChild(nodes[(i - 1) * n + j - 1]);
        // above right
        // node.addChild(nodes[(i - 1) * n + j + 1]);
        // left
        node.addChild(i * nWide + j - 1);
      }
    }
  }

  // Create the application helper and add its render target to the page
  let app = new PIXI.Application({ antialias: true, background: '0xffffff', width: width, height: height });
  document.body.appendChild(app.view);
  setup();
  const mouse = new PIXI.Point();
  let mouseIsPressed = false;
  app.stage.interactive = true;
  app.stage.hitArea = app.screen;
  app.stage.addEventListener('pointermove', (e) => {
    mouse.copyFrom(e.global);
    if (mouseIsPressed) {
      mouseNode.obj.position.copyFrom(mouse);
    }
  });
  app.stage.addEventListener('pointerdown', (event) => {
    mouseIsPressed = true;
  });
  app.stage.addEventListener('pointerup', (event) => {
    mouseIsPressed = false;
  });
  app.ticker.add((delta) => {
    if (state === 1) {
      return;
    }
    for (const node of Object.values(nodes)) {
      if (createVector(mouse.x, mouse.y).subtract(node.obj.position).magnitude() < 10) {
        if (!mouseIsPressed) {
          mouseNode = node;
        }
      }
      if (mouseNode !== node || !mouseIsPressed) {
        node.updateAverage();
      }
    }

    for (const node of Object.values(nodes)) {
      if (mouseNode !== node || !mouseIsPressed) {
        node.updatePhysics()
      }
    }
  });
</script>
</body>
</html>